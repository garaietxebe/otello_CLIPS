; Othello jokoa
; Autores: Garai eta Urdax
; Data: 30/04/2025 - ...


; Definición de plantillas

; Plantilla para representar el tablero
(deftemplate tablero
   (slot dimension (type INTEGER) (default 8))
   (slot turno (type SYMBOL) (allowed-values negro blanco) (default negro)))

; Plantilla para representar una casilla del tablero
(deftemplate casilla
   (slot fila (type INTEGER))
   (slot columna (type INTEGER))
   (slot estado (type SYMBOL) (allowed-values vacia negra blanca) (default vacia)))

; Plantilla para representar la cantidad de fichas disponibles de cada jugador
(deftemplate fichas-disponibles
   (slot jugador (type SYMBOL) (allowed-values negro blanco))
   (slot cantidad (type INTEGER) (default 30)))

; Plantilla para mostrar mensajes al usuario
(deftemplate mensaje
   (slot texto (type STRING)))

; Plantilla para controlar la visualización del tablero
(deftemplate visualizar
   (slot mostrar (type SYMBOL) (allowed-values si no) (default no)))

; Reglas del juego

; Regla para inicializar el tablero
(defrule inicializar-tablero
   (declare (salience 100))
   (not (tablero))
   =>
   (assert (tablero))
   (assert (mensaje (texto "Tablero inicializado. Dimension: 8x8"))))

; Regla para inicializar las fichas disponibles
(defrule inicializar-fichas
   (declare (salience 99))
   (not (fichas-disponibles (jugador negro)))
   (not (fichas-disponibles (jugador blanco)))
   =>
   (assert (fichas-disponibles (jugador negro) (cantidad 30)))
   (assert (fichas-disponibles (jugador blanco) (cantidad 30)))
   (assert (mensaje (texto "Fichas inicializadas. Cada jugador tiene 30 fichas disponibles."))))

; Regla para crear casillas vacías
(defrule crear-casillas-vacias
   (declare (salience 98))
   (tablero (dimension ?dim))
   (not (casilla (fila 1) (columna 1)))
   =>
   (loop-for-count (?i 1 ?dim) do
      (loop-for-count (?j 1 ?dim) do
         (assert (casilla (fila ?i) (columna ?j) (estado vacia))))))

; Regla para colocar las fichas iniciales en el centro del tablero
(defrule colocar-fichas-iniciales
   (declare (salience 97))
   ?t <- (tablero (dimension ?dim))
   ?c1 <- (casilla (fila ?mid) (columna ?mid) (estado vacia))
   ?c2 <- (casilla (fila ?mid) (columna ?mid2) (estado vacia))
   ?c3 <- (casilla (fila ?mid2) (columna ?mid) (estado vacia))
   ?c4 <- (casilla (fila ?mid2) (columna ?mid2) (estado vacia))
   ?f1 <- (fichas-disponibles (jugador negro) (cantidad ?cant-negro))
   ?f2 <- (fichas-disponibles (jugador blanco) (cantidad ?cant-blanco))
   (test (= ?mid (/ ?dim 2)))
   (test (= ?mid2 (+ ?mid 1)))
   =>
   (modify ?c1 (estado blanca))
   (modify ?c2 (estado negra))
   (modify ?c3 (estado negra))
   (modify ?c4 (estado blanca))
   (modify ?f1 (cantidad (- ?cant-negro 2)))
   (modify ?f2 (cantidad (- ?cant-blanco 2)))
   (assert (mensaje (texto "Fichas iniciales colocadas en el tablero.")))
   (assert (visualizar (mostrar si))))  ; Activar la visualización del tablero después de colocar las fichas iniciales

; Regla para mostrar el estado del tablero
(defrule mostrar-tablero
   (declare (salience -100))
   (tablero (dimension ?dim) (turno ?turno))
      ?v <- (visualizar (mostrar si))
   =>
   (printout t crlf)
   (printout t "Estado del tablero:" crlf)
   (printout t "Turno: " ?turno crlf)
   (printout t "  ")
   (loop-for-count (?j 1 ?dim) do
      (printout t ?j " "))
   (printout t crlf)
   (loop-for-count (?i 1 ?dim) do
      (printout t ?i " ")
      (loop-for-count (?j 1 ?dim) do
         (bind ?estado (fact-slot-value (nth$ 1 (find-fact ((?c casilla)) (and (eq ?c:fila ?i) (eq ?c:columna ?j)))) estado))
         (if (eq ?estado vacia)
             then (printout t "· ")
             else (if (eq ?estado negra)
                   then (printout t "N ")
                   else (printout t "B "))))
      (printout t crlf))
   (printout t crlf)
   (retract ?v))

; Regla para mostrar mensajes
(defrule mostrar-mensaje
   ?m <- (mensaje (texto ?texto))
   =>
   (printout t ?texto crlf)
   (retract ?m))

; Función para iniciar el juego
(deffunction iniciar-juego ()
   (reset)
   (run))

; Función para mostrar el tablero manualmente
(deffunction mostrar ()
   (assert (visualizar (mostrar si)))
   (run))

 ;okupatuta_dago

   (deffunction okupatuta_dago (?fila ?columna)
   ; TRUE okupauta
   ; FALSE hutsa
   
   ; Bilatu
   (bind ?casillas (find-fact ((?c casilla)) 
                              (and (eq ?c:fila ?fila) 
                                   (eq ?c:columna ?columna))))
   
   (bind ?casilla (nth$ 1 ?casillas))
   (bind ?estado (fact-slot-value ?casilla estado))
   
   (if (eq ?estado vacia)
       then
       (return FALSE)  ; No está ocupada
       else
       (return TRUE)   ; Está ocupada (negra o blanca)
   )
)



(deffunction mugimendu_egokia (?fila ?columna ?estado)
   ;  1. ¿Está dentro del tablero?
   (if (not (and (>= ?fila 1)(<= ?fila 8) (>= ?columna 1)(<= ?columna 8)))
       then
       (printout t "Error: Posición fuera del tablero (" ?fila "," ?columna ")." crlf)
       (return FALSE))

   ; 2. ¿Color válido?
   (if (not (or (eq ?estado negra) (eq ?estado blanca)))
       then
       (printout t "Error: Color no válido. Solo 'negra' o 'blanca'." crlf)
       (return FALSE))

   ; 3. ¿Casilla vacía?
   (if (okupatuta_dago ?fila ?columna)  ; Verifica si ya hay una ficha
       then
       (printout t "Error: Casilla ocupada (" ?fila "," ?columna ")." crlf)
       (return FALSE))
   
   ; 4. ¿Flanquea al menos una ficha?
   (bind ?opposite (if (eq ?estado negra) then blanca else negra))
   (bind ?found FALSE)
   
   ; Verificar en las 8 direcciones
   (loop-for-count (?dx -1 1) do
      (loop-for-count (?dy -1 1) do
         (if (and (not (and (eq ?dx 0) (eq ?dy 0)))  ; No es la propia casilla
                  (>= (+ ?fila ?dx) 1) (<= (+ ?fila ?dx) 8)
                  (>= (+ ?columna ?dy) 1) (<= (+ ?columna ?dy) 8))
             then
             (bind ?x (+ ?fila ?dx))
             (bind ?y (+ ?columna ?dy))
             ; Verificar casilla adyacente
             (bind ?neighbor (nth$ 1 (find-fact ((?c casilla))
                                                (and (eq ?c:fila ?x)
                                                     (eq ?c:columna ?y)))))
             (if (eq (fact-slot-value ?neighbor estado) ?opposite)
                 then
                 ; Seguir en esta dirección
                 (bind ?x (+ ?x ?dx))
                 (bind ?y (+ ?y ?dy))
                 (while (and (>= ?x 1) (<= ?x 8) (>= ?y 1) (<= ?y 8))
                    (bind ?neighbor (nth$ 1 (find-fact ((?c casilla))
                                                       (and (eq ?c:fila ?x)
                                                            (eq ?c:columna ?y)))))
                    (if (eq (fact-slot-value ?neighbor estado) ?estado)
                        then
                        (bind ?found TRUE)
                        (break))
                    (if (eq (fact-slot-value ?neighbor estado) vacia)
                        then
                        (break))
                    ; Mover a siguiente casilla
                    (bind ?x (+ ?x ?dx))
                    (bind ?y (+ ?y ?dy))
                 )
             )
         )
      )
   )
   
   (if (not ?found)
       then
       (printout t "Error: No hay fichas del oponente para flanquear (" ?fila "," ?columna ")." crlf))
   
   (return ?found)
)

(deffunction mostrar-movimientos-disponibles (?estado)
   (printout t "Mugimendu posibleak " ?estado "entzat:" crlf)
   (bind ?count 0)
   
   (loop-for-count (?fila 1 8) do
      (loop-for-count (?columna 1 8) do
         (if (and (not (okupatuta_dago ?fila ?columna))
                 (mugimendu_egokia ?fila ?columna ?estado))
             then
             (printout t "(" ?fila "," ?columna ") ")
             (bind ?count (+ ?count 1))
         )
      )
   )
   
   (if (= ?count 0)
       then (printout t "Ez dago mugimendu posibleik." crlf)
       else (printout t crlf))
   
   (printout t "Guztira: " ?count " mugimendu" crlf )
)

(deffunction anadir-pieza (?fila ?columna ?estado)
   (if (not (mugimendu_egokia ?fila ?columna ?estado))
       then
       (return FALSE))
   
   ; Colocar la ficha
   (bind ?c (nth$ 1 (find-fact ((?c casilla))
                           (and (eq ?c:fila ?fila)
                                (eq ?c:columna ?columna)))))
   (modify ?c (estado ?estado))
   
   ; Voltear las fichas del oponente
   (bind ?opposite (if (eq ?estado negra) then blanca else negra))
   (loop-for-count (?dx -1 1) do
      (loop-for-count (?dy -1 1) do
         (if (and (not (and (eq ?dx 0) (eq ?dy 0)))
                  (>= (+ ?fila ?dx) 1) (<= (+ ?fila ?dx) 8)
                  (>= (+ ?columna ?dy) 1) (<= (+ ?columna ?dy) 8))
             then
             (bind ?x (+ ?fila ?dx))
             (bind ?y (+ ?columna ?dy))
             (bind ?neighbor (nth$ 1 (find-fact ((?c casilla))
                                                (and (eq ?c:fila ?x)
                                                     (eq ?c:columna ?y)))))
             (if (eq (fact-slot-value ?neighbor estado) ?opposite)
                 then
                 (bind ?to-flip (create$))
                 (bind ?x (+ ?x ?dx))
                 (bind ?y (+ ?y ?dy))
                 (while (and (>= ?x 1) (<= ?x 8) (>= ?y 1) (<= ?y 8))
                    (bind ?neighbor (nth$ 1 (find-fact ((?c casilla))
                                                       (and (eq ?c:fila ?x)
                                                            (eq ?c:columna ?y)))))
                    (if (eq (fact-slot-value ?neighbor estado) ?opposite)
                        then
                        (bind ?to-flip (create$ ?to-flip ?neighbor))
                        (bind ?x (+ ?x ?dx))
                        (bind ?y (+ ?y ?dy))
                        else
                        (if (eq (fact-slot-value ?neighbor estado) ?estado)
                            then
                            (foreach ?piece ?to-flip
                               (modify ?piece (estado ?estado)))
                            (break))
                        (if (eq (fact-slot-value ?neighbor estado) vacia)
                            then
                            (break))
                    )
                 )
             )
         )
      )
   )
   
   (printout t "(" ?fila ", " ?columna ") kolorea: " ?estado crlf)
   (mostrar)

   ; Mostrar movimientos del siguiente jugador
   (if (eq ?estado negra)
       then
       (printout t crlf ">>> Turno de BLANCAS:" crlf)
       (mostrar-movimientos-disponibles blanca)
       else
       (printout t crlf ">>> Turno de NEGRAS:" crlf)
       (mostrar-movimientos-disponibles negra)
   )

(return TRUE)

)
